<p><h1>Task - url shortening service</h1>


<h3 class="heading-h3-blue" id="description">Description</h3>

<p>
    The task is to make a simple url shortening service that can be run on several nodes
    providing basic scalable cluster
</p>

<div style="text-align: center">
    <img src="resources/task-short-url-pic1.png" />
</div>

<h3 class="heading-h3-blue" id="terms">Terms and definitions</h3>

<ul>
    <li><b>Long url</b> - passed as input to shortening service, contains only ASCII symbols. Example: http:/mysite.com/my-long-url</li>
    <li><b>Short url</b> - returned by shortening service, contains only 0-9, a-z and A-Z symbols, max length 8 chars (assuming max number of long urls is less than 10^8). Example: rT23Z7</li>
    <li><b>Service node</b> - single process of shortening service running in the operating system, several nodes may
        be launched on different machines, but they should share data is some way, soeach node should be able to server each request.</li>
</ul>

<h3
        class="heading-h3-blue"
        id="service"
        onclick="$('#service-content').toggle(200)">
    Service API <span class="glyphicon glyphicon-triangle-bottom" style="font-size: 20px" aria-hidden="true"></span>
</h3>
<div id="service-content" style="display: none">
    The task is to provide HTTP API of 3 operations:<br><br>

    <div class="well">
        POST /shorten<br><br>

        Example request:<br>
        POST /shorten<br>
        http:/mysite.com/my-long-url<br><br>

        Example response:<br>
        200 OK<br>
        rT23Z7
    </div>

    Url to shorten is passed in request body. Answer should be 200 OK with short url in response body.<br>


    <div class="well">
        POST /expand<br><br>

        Example request:<br>
        POST /expand<br>
        rT23Z7<br><br>

        Example response:<br>
        200 OK<br>
        http:/mysite.com/my-long-url
    </div>

    Short url (previously generated by service) is passed in request body. Answer should be 200 OK with original url in response body.<br><br>

    <div class="well">
        GET /status
    </div>

    Simply returns 200 OK if this node is ready to serve requests. Used to determine moment then node fully started.<br><br>

    <div class="panel panel-success">
        <div class="panel-heading"><b>Functional requirements</b></div>
        <div class="panel-body">
            <ul>
                <li>Max long url length 10Kb</li>
                <li>Well, in our tests long url may not actually be url - so random string should be accepted too</li>
                <li>If input url is unknown or some other error occured - return HTTP code 500</li>
            </ul>
        </div>
    </div>

    <div class="panel panel-info">
        <div class="panel-heading"><b>Non-functional requirements</b></div>
        <div class="panel-body">
            <ul>
                <li>Total amount of input long urls may not fit into memory</li>
                <li>Runtime addition/deletion of nodes is not required in this task</li>
                <li>The faster response is returned - the better</li>
            </ul>
        </div>
    </div>
</div>

<h3
        class="heading-h3-blue"
        id="cluster"
        onclick="$('#cluster-content').toggle(200)">
    Cluster tests description<span class="glyphicon glyphicon-triangle-bottom" style="font-size: 20px" aria-hidden="true"></span>
</h3>
<div id="cluster-content" style="display: none">
    <p>
        In some tests we launch several nodes and then randomly choose node for each request. So the may be a situation when
        we shortened url on node 1 and then try to expand it on node 2 - this must be handled correctly.
    </p>
    <p>
        In this task we make the most basic cluster without fault-tolerance or runtime addition/deletion of nodes. So
        in each test we take a set of clean virtual machines (VMs) and launch a node on each. When all nodes are up
        (/status returns 200) we start the actual test. After test completion we recreate VMs so you don't need to clean
        up any data on disk.
    </p>
    <p>
        Your nodes in cluster will likely need to communicate with each other - each node is provided with config file
        for this purpose. It contains list of all nodes and id of this node. Feel free to bind additional sockets if you
        need.
    </p>
    <p>
        For some tests we may launch only 1 node, for others - several. Config provided to each node lists current
        cluster setup (number of nodes, ips, etc.).
    </p>
</div>

<h3
        class="heading-h3-blue"
        id="environment"
        onclick="$('#environment-content').toggle(200)">
    Environment <span class="glyphicon glyphicon-triangle-bottom" style="font-size: 20px" aria-hidden="true"></span>
</h3>

<div id="environment-content" style="display: none">
    <p>
        Your app will be started as a separate process. To view exact command used to launch executable of your
        type check <a href="/supported-exec-types.jsp">supported executable file types</a>. A single argument will be
        passed to your app - path to config file with properties describing the environment.
    </p>

    <b>Config file format:</b>
    <div class="well">
        property1=value1<br>
        property2=value2<br>
    </div>

    <b>Properties:</b>
    <ul>
        <li><b>nodes</b> - total number of nodes in cluster
        <li><b>node-X</b> - several properties containing "ip:port" where HTTP API of that node
        must be available. So in case of "nodes=2" property there will be something like: "node-0=192.168.0.2:8080" and
        "node-1=192.168.0.3:8080" properties. First node has index 0.
        <li><b>thisNodeIndex</b> - index of this node, index is that X in previous "node-X" property, so "thisNodeIndex=1" means
        this node HTTP is expected at "node-1=192.168.0.3:8080" address.
        <li><b>memoryLimitBytes</b> - total amount of memory available for VM (in case you need it to configure caching correctly)
    </ul>
</div>


<h3
        class="heading-h3-blue"
        id="notes"
        onclick="$('#notes-content').toggle(200)">
    Final notes <span class="glyphicon glyphicon-triangle-bottom" style="font-size: 20px" aria-hidden="true"></span>
</h3>

<div id="notes-content" style="display: none">
    <ul>
        <li> Input long urls are guaranteed to be valid - no empty values, illegal chars, etc.</li>
        <li> Our tests may provide up to 1Gb of total input long urls</li>
        <li> Start with simpliest implementation that actually works</li>
    </ul>
</div>